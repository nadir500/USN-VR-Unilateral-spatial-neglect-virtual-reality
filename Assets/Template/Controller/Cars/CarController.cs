using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CarController : MonoBehaviour
{
    /*
     Car Controller aims to generate cars on the roads that is generated by road controller class 
     */

    [HideInInspector]
    public const float streetPathWidth = 5;        //  the width of pair of paths
    public const float sidewalkWidth = 5f;         //  the width of sidewalk
    public const float midwalkWidth = 1.36f;       //  the width of midwalk
    int numberOfPathsInSingleRoad;
    public CheckPointsController checkPointsController;  //reaching checkpoint controller for event subscribe when generate at the start of the game 
    
    public GameObjectHandler[] carObjectHandlerArray;
    public RoadController roadsController;
    void Start()
    {
        InitializeCars();
    }

    void InitializeCars()
    {
        checkPointsController.startTheGameCheckPointReachedEvent += CarsOnFastRoad; //subscribe the event 
    }

    public void CarsOnFastRoad()
    {
        if (MainMenu.playMode == 1)
        {
            numberOfPathsInSingleRoad = ExperimentParameters.lanes_per_direction;
            carObjectHandlerArray = new GameObjectHandler[3];
            //switch cases 
            if (ExperimentParameters.carType != "All")
            {
                switch (ExperimentParameters.carType)
                {

                    case "Car":
                        carObjectHandlerArray[0] =
                            new GameObjectHandler(Resources.Load("Prefabs/Car") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                            ExperimentParameters.numberOfRoads * 10 * 2, true, "");          //making a prefab copy with a number enough to cover a whole one path 

                        break;
                    case "Truck":
                        carObjectHandlerArray[1] =
                              new GameObjectHandler(Resources.Load("Prefabs/Truck") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                              numberOfPathsInSingleRoad * 10 * 2, true, "");          //making a prefab copy with a number enough to cover a whole one path 

                        break;
                    case "Bus":
                        carObjectHandlerArray[2] =
                              new GameObjectHandler(Resources.Load("Prefabs/Bus") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                              numberOfPathsInSingleRoad * 10 * 2, true, "");          //making a prefab copy with a number enough to cover a whole one path 

                        break;
                }
                carObjectHandlerArray[0].DeactivateAll();
            }
            else
            {
                carObjectHandlerArray[0] =
                        new GameObjectHandler(Resources.Load("Prefabs/Car") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                        ExperimentParameters.numberOfRoads * 10, true, "");          //making a prefab copy with a number enough to cover a whole one path 
                carObjectHandlerArray[1] =
                            new GameObjectHandler(Resources.Load("Prefabs/Truck") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                            ExperimentParameters.numberOfRoads * 10, true, "");          //making a prefab copy with a number enough to cover a whole one path 
                carObjectHandlerArray[2] =
                                        new GameObjectHandler(Resources.Load("Prefabs/Bus") as GameObject, //pooling from the prefab with copies that is like the number of paths in each street
                                                        ExperimentParameters.numberOfRoads * 10, true, "");          //making a prefab copy with a number enough to cover a whole one path 

            }



            InstantiateCarsFastRoad(carObjectHandlerArray);
            //carObjectHandler.DeactivateAll(); //deactivate all the cars after putting every component we want 
        }

    }
    /*we need to instantiate the cars in the scene with the perfect positions on the road when generating it */
    public void InstantiateCarsFastRoad(GameObjectHandler[] carObjectHandler)
    {
        //knowing which rotation and direction to instantiate the car
        string[] carDirection = ExperimentParameters.streetsDirections.Split(' ');

        int numberOfRoads = ExperimentParameters.numberOfRoads * ExperimentParameters.lanes_per_direction / 2;
        int countingRoadsForCars = 0;
        int roadsToGenerate = ExperimentParameters.lanes_per_direction / 2; //for each Road GameObject
        int counterToGenerateNextRoadsOnMidwalk = 0;


        for (int i = 0; i < numberOfRoads; i++) //2 cars each road GameObject
        {
            //now i am seperating between going cars which is the cars from left to right direction
            //and back cars which is from right to left direction
            GameObject parent1 = new GameObject("parent " + i);      //making parent object for each generated lane's cars 
            GameObject parent2 = new GameObject("ٌReverse " + i);    //making parent object for each generated lane's cars

            GameObject car1, car2;
            int yRotate;  //to know the rotation of the car before instantiate 


            if (roadsToGenerate <= (counterToGenerateNextRoadsOnMidwalk))
            {

                counterToGenerateNextRoadsOnMidwalk = 0;
            countingRoadsForCars++;

            }
            counterToGenerateNextRoadsOnMidwalk++;
            for (int j = 0; j < 10; j++)  //number of cars generated 
            {
                if (ExperimentParameters.carType != "All")
                {
                    InstantiateCarsLeftLane(carObjectHandler[0], i, parent1);
                    InstantiateCarsRightLane(carObjectHandler[0], i /*+ 1*/, parent1);
                }
                else
                {
                    if (carObjectHandlerArray.Length - 1 >= countingRoadsForCars)
                    {
                        //////choose cars and generate for each road 
                         InstantiateCarsLeftLane(carObjectHandler[countingRoadsForCars], i, parent1); // ||  left in road    ||           ||  in terms of left to right road 

                         InstantiateCarsRightLane(carObjectHandler[countingRoadsForCars], i /* + 1*/, parent1);   // ||           ||   right in road        ||   in terms of left to right road 
                    }
                    else
                    {
                        countingRoadsForCars = 0;
                    }

                }


                if (ExperimentParameters.streetsDirections.Split(' ').Length > 1) //two sides (UNDER CONSTRUCTION)
                {
                    yRotate = (ExperimentParameters.streetsDirections.Equals("Left To Right")) ? -1 : 1;
                    car2 = carObjectHandler[0].RetrieveInstance(new Vector3(/*-0.2f +*/ sidewalkWidth + (numberOfPathsInSingleRoad * (streetPathWidth / 2)) + midwalkWidth + (streetPathWidth / 4) + (i * (streetPathWidth / 2)), -2.0f, yRotate * (190.0f + ExperimentParameters.distanceBetweenCars)), Quaternion.Euler(new Vector3(0, yRotate * -90, 0)));
                    car2.AddComponent<CarMove>();   //adding the CarMove Script  
                    car2.GetComponent<CarMove>().carDirection = ExperimentParameters.streetsDirections.Split()[2];  //describe which direction 
                    car2.transform.parent = parent2.transform; //putting the instantiated car to a parent 
                }

            }

            parent1.AddComponent<CarParentOnRoad>(); //adding a class to the parent (each lane) to manage the cars in the scene
          //  parent2.AddComponent<CarParentOnRoad>(); //adding a class to the parent (each lane) to manage the cars in the scene
        }


    }

    
    GameObject InstantiateCarsLeftLane(GameObjectHandler carHandler, int index, GameObject parent)
    {
        int yRotate;  //to know the rotation of the car before instantiate 
        float carMeasure = 0;
        yRotate = (ExperimentParameters.streetsDirections.Split()[0].Equals("Right")) ? -1 : +1;  //identify the rotation 

       
           // carMeasure = (sidewalkWidth) + (index * ((streetPathWidth))) + ((index) * midwalkWidth) + (streetPathWidth / 4);
            carMeasure = roadsController.roadsArray[index].transform.position.x -  1.06f;
        
        

        GameObject car = carHandler.RetrieveInstance(new Vector3(carMeasure,
                           -2.0f, yRotate * (190.0f + ExperimentParameters.distanceBetweenCars)),
                                              Quaternion.Euler(new Vector3(0, yRotate * -90, 0)));

        car.AddComponent<CarMove>();  //adding the CarMove Script  
        car.GetComponent<CarMove>().carDirection = ExperimentParameters.streetsDirections.Split()[0];      //describe which direction 

        car.transform.parent = parent.transform; //putting the instantiated car to a parent 
        return car;

    }

    GameObject InstantiateCarsRightLane(GameObjectHandler carHandler, int index, GameObject parent)
    {
        int yRotate;  //to know the rotation of the car before instantiate 
        float carMeasure = 0;

        yRotate = (ExperimentParameters.streetsDirections.Split()[0].Equals("Right")) ? -1 : +1;  //identify the rotation 
       
           /// carMeasure = (sidewalkWidth) + ((index - 1) * ((streetPathWidth))) + ((index - 1) * midwalkWidth) + (streetPathWidth * 3 / 4);
          carMeasure = roadsController.roadsArray[index].transform.position.x + 1.06f ;

      
        
        GameObject car = carHandler.RetrieveInstance(new Vector3(carMeasure,
                     -2.0f, yRotate * (190.0f + ExperimentParameters.distanceBetweenCars)),
                                        Quaternion.Euler(new Vector3(0, yRotate * -90, 0)));

        car.AddComponent<CarMove>();  //adding the CarMove Script  
        car.GetComponent<CarMove>().carDirection = ExperimentParameters.streetsDirections.Split()[0];      //describe which direction 
        car.transform.parent = parent.transform; //putting the instantiated car to a parent 
        return car;

    }
}